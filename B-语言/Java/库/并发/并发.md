# 并发

让我们重新演绎并发编程的历史

## 1. 为什么我们需要并发？

在回答这个问题之前，我们需要先搞清楚并发和并行这2个概念上的区别。

- 并发：同一时间应对（dealing with）多件事情的能力。
- 并行：同一时间动手做（doing）多件事情的能力。

这里需要**==注意==**一点：单CPU也能并发，但是不能并行，只有多个CPU才能并行。

并发是为了：多任务、提高响应、提高CPU利用率。

- 多任务、提高响应：让用户看来起来同时执行了多任务，实际上可能只是交替执行的，只是切换的速度比较快，用户看不出来。
- 提高CPU利用率：如果一个任务阻塞了，可以先做其他任务，不至于让CPU在那空等。

## 2. 并发的时候，有哪些参与者？

并发是做事，也就是逻辑学中的事件，参与事件的有哪些事物？为什么要先搞清楚这个呢？因为做事的时候首先得有人做吧？

- 任务：用户想做的事。
- 线程：有点类似工作台，需要保存做任务时临时数据。就像一个维修工作台，需要保存拆开的设备的零件。
- 线程池：一堆工作台。
- 执行器：执行器是**==工作台 + worker任务==**。

任务和线程的关系有点模板方法模式的感觉。在这里，线程是模板，任务是模板上空白的部分。对于线程这个模板来说，没有任务的空模板线程没有意义。对于任务来说，没有线程这个模板，任务就无法并发执行，但是我们需要的就是并发。

### 2.1 任务



### 2.2 执行器

执行器是一个复合体，由线程和worker任务组成。这个worker任务的工作内容是：从==**用户任务**==队列中获取**用户任务**，然后做，做完了之后再去取另一个用户任务，这样不断的做，只有当接收到用户任务做完了，或者收到命令不再执行了，才停止。

## 3. 并发时修改共享数据怎么办？

### 解决方案—锁模型

当我们重新演绎并发的发展历程的时候，自然而然会遇到前辈们遇到的问题，遇到了问题要解决。这里我们参照生活中的经验，给共享资源加锁。

这里需要**==注意==**的是：

1. 锁并不是真的锁，只是一个标识，就像公路维护工人会在维修公路的时候放一个黄色的牌子，上面写着：“正在修路，请绕行”一样，这个牌子就是锁。在 java中，可以任意创建一个对象当作锁牌。
2. 不能在任务中**创建**锁，因为CPU在执行A任务时在内存中创建了一个对象当作锁，这个对象只有A知道，没通过参数传给B，B是拿不到这个引用的；同理B创建的A也不知道。**==锁和资源一样，也必须是共享的==**。既然如此，可以把资源和锁绑到一起：一是用锁对象封装资源变量，二是资源对象的对象头当作锁。

#### Java提供的锁

解决思路已经有了，那么 java 是否提供了这个思路的对应实现呢？答案是肯定的。java 提供了2种方案。

##### 内置锁

##### 并发库中的锁

### 锁模型的缺陷—死锁

使用锁模型是能解决修改共享变量的问题，但没有完美的方案。锁模型也带来了新的问题：死锁。这是矛盾论，世界是发展的，矛盾也永不停止。

#### 解决办法

迄今为止，一旦死锁，只能终止 JVM 运行。

#### 如何避免死锁？

既然死锁发生之后没有好的解决办法，那么能不能不让死锁发生呢？答案是肯定的。

有个叫Coffman的人分析了死锁发生的原因，并做了总结。当以下4个条件同时满足的时候才会发生死锁：

1. 互斥，共享资源 X 和 Y 只能被一个线程占用；
2. 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
3. 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

反过来分析，也就是说只要我们破坏其中一个，就可以避免死锁的发生。

其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的：

1. 对于“占用且等待”：我们可以一次性拿到所有资源，这样就不存在等待了。
2. 对于“不可抢占”：不能强行抢占，但是可以让出自己占有的资源，这样不可抢占这个条件就破坏掉了（**==注意==**：这个java的内置锁是做不到的）。
3. 对于“循环等待”：可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。

### 硬件结构和编译器导致的问题

除了解决方案模型本身的缺陷，还有硬件以及编译器带来的问题。主要是缓存和重排序，既然是缓存和重排序带来的问题，那么就禁用缓存和重排序。提供的几种解决方案的差异主要是在禁用的范围，已经怎样禁用。

- 可见性
  - 原因：缓存导致
  - 解决办法：Java内存模型——volatile 禁用缓存
- 有序性
  - 原因：编译器优化
  - 解决办法：Java内存模型——Happens-Before 规则 + volatile 和 final 禁止重排序
- 原子性
  - 原因：线程切换
  - 解决办法：互斥锁——synchronized

## 4. 工具

**==线程与锁模型==**其实是对**==底层硬件运行过程==**的形式化。这种形式化既是该模型最大的优点，也是它最大的缺点。

线程与锁模型非常简单直接，几乎所有编程语言都以某种形式对其提供了支持，且不对其使用方式加以限制。换句话说，对于不精通该模型的程序员，编程语言没有提供足够的帮助，使得程序**容易出错**且**难以维护**。





