# 代理模式

## 代理原理

代理模式（Proxy Design Pattern）的**==原理和代码==**实现都**==不难掌握==**。它在==**不改变原始类**==（或叫被代理类）代码的情况下，通过引入代理类来给原始类**==附加功能==**。

## 静态代理

### 实现

一般情况下，我们让代理类和原始类==实现同样的接口==。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类==继承原始类==的方法来实现代理模式。

## 动态代理

### 原理

静态代理存在一些问题：

- 一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为==每个方法==都附加==相似==的代码逻辑。
- 另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。如果有 50 个要添加附加功能的原始类，那我们就要创建 50 个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点==像模板式的“重复”代码==，也增加了不必要的开发成本。

对于静态代理存在的问题，我们可以通过动态代理来解决。

动态代理（Dynamic Proxy）：我们==不事先==为每个原始类==编写代理类==，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

### 实现

Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）。

## 代理模式的应用场景

### 业务系统的非功能性需求开发

### 在 RPC、缓存中的应用

