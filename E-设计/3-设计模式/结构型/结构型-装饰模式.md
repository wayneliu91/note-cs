# 装饰模式

## 主要解决

附加更多的增强功能，如果使用继承，会导致==组合爆炸==，类继承结构变得无比复杂，代码既不好扩展，也不好维护。

用组合替代继承，解决继承关系过于复杂的问题。

## 主要作用

给原始类==添加增强功能==。这也是==判断是否该用==装饰器模式的一个重要的依据。

## 特点

可以对原始类==嵌套使用==多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类==继承相同的抽象类或者接口==。

可以参考 JavaIO 案例。

## 与简单组合关系的区别

相对于==简单的组合关系==，还有==两个比较特殊的地方==。

- 装饰器类和原始类==继承同样的父类==，这样我们可以对原始类“==嵌套==”多个装饰器类。
- 装饰器类是==对功能的增强==，这也是装饰器模式应用场景的一个重要特点。

## 与其他模式的区别

符合“组合关系”这种代码结构的设计模式有很多，比如：代理模式、桥接模式，还有现在的装饰器模式。

尽管它们的==代码结构很相似==，但是每种设计模式的==意图是不同的==。

### 与代理模式的区别

就拿比较相似的代理模式和装饰器模式来说，代理模式中，代理类附加的是==跟原始类无关==的功能，而在装饰器模式中，装饰器类附加的是==跟原始类相关==的==增强==功能。



## 代理、桥接、装饰器、适配器 4 种模式的区别

代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的==代码结构==非常相似。

笼统来说，它们都可以称为 ==Wrapper 模式==，也就是通过 Wrapper 类==二次封装==原始类。

尽管代码结构相似，但这 4 种设计模式的==用意==完全不同，也就是说==要解决的问题、应用场景==不同，这也是它们的==主要区别==。

- 代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，==主要目的==是**==控制访问==**，而**==非加强功能==**，这是它跟装饰器模式==最大的不同==。
- 桥接模式：桥接模式的==目的==是将==接口部分==和==实现部分==分离，从而让它们可以较为容易、也相对独立地加以改变。
- 装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行==增强==，并且==支持==多个装饰器的==嵌套使用==。
- 适配器模式：适配器模式是一种==事后的补救策略==。适配器提供跟原始类==不同的接口==，而代理模式、装饰器模式提供的都是跟原始类==相同的接口==。

