# 生成器模式

建造者模式的原理和代码实现非常简单，掌握起来并不难，==难点在于应用场景==。重点是掌握应用场景，避免过度使用。

## 为什么需要建造者模式？

如果一个类中有很多属性，为了避免==构造函数==的==参数列表过长==，影响代码的==可读性==和==易用性==，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。

- 我们把类的==必填属性==放到构造函数中，强制创建对象的时候就设置。如果==必填属性有很多==，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那==校验这些必填属性是否已经填写==的逻辑就无处安放了。
- 如果类的==属性之间==有一定的==依赖关系==或者==约束条件==，我们继续使用构造函数配合 set() 方法的设计思路，那这些==依赖关系或约束条件的校验逻辑==就无处安放了。
- 如果我们希望创建==不可变对象==，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就==不能在类中暴露 set() 方法==。==构造函数配合 set() 方法==来设置属性值的方式就==不适用==了。

使用建造者模式创建对象，还能避免对象存在==无效状态==。举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态。

为了避免这种无效状态的存在，我们就需要==使用构造函数一次性初始化好所有的成员变量==。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。

如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是==有点重复==的，因为类中的成员变量，要在 Builder 类中==重新再定义一遍==。

## 实现

把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。

除此之外，我们把构造函数改为 private 私有权限。这样我们就只能通过建造者来创建类对象。并且，类对象不提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。

## 与工厂模式有何区别？

- 工厂模式是用来创建==不同但是相关类型==的对象（继承同一父类或者接口的一组子类），由==给定的参数==来==决定==要创建的对象的==类型==。
- 建造者模式是用来创建==一种类型==的==复杂对象==，可以通过设置不同的可选参数，“==定制化==”地创建不同的对象。

实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。

**只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以==混用各种模式==创造出新的模式，来解决特定场景的问题**。

