# 2-代码实现

## 业务开发包括哪些工作？

实际上，我们平时做业务系统的设计与开发，无外乎有这样三方面的工作要做：

- 接口设计。
- 数据库设计。
- 业务模型设计（也就是业务逻辑）。

数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动。

- 改动**数据库表结构**，需要涉及数据的**迁移**和**适配**；
- 改动**接口**，需要推动**接口的使用者**作相应的代码修改。

这两种情况，即便是微小的改动，执行起来都会非常麻烦。因此，我们在设计接口和数据库的时候，一定要多花点心思和时间，切不可过于随意。相反，**业务逻辑代码**侧重内部实现，不涉及被外部依赖的接口，也不包含持久化的数据，所以**对改动的容忍性更大**。

接口设计要符合单一职责原则，粒度越小通用性就越好。但是，接口粒度太小也会带来一些问题。比如，一个功能的实现要调用多个小接口，

- 一方面，如果接口调用走网络（特别是公网），多次远程接口调用会**影响性能**；
- 另一方面，本该在一个接口中完成的原子操作，现在分拆成多个小接口来完成，就可能会涉及**分布式事务**的**数据一致性问题**（一个接口执行成功了，但另一个接口执行失败了）。

所以，为了兼顾易用性和性能，我们可以借鉴 **facade（外观）设计模式**，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。

## 为什么要分 MVC 三层开发？

- Controller 层负责**接口暴露**。
- Repository 层负责**数据读写**。
- Service 层负责**核心业务逻辑**，也就是**业务模型**。

### 1. 分层能起到**代码复用**的作用

同一个 Repository 可能会被多个 Service 来调用，同一个 Service 可能会被多个 Controller 调用。比如，UserService 中的 getUserById() 接口封装了通过 ID 获取用户信息的逻辑，这部分逻辑可能会被 UserController 和 AdminController 等多个 Controller 使用。如果没有 Service 层，每个 Controller 都要重复实现这部分逻辑，显然会**违反 DRY 原则**。

### 2. 分层能起到**隔离变化**的作用

分层体现了一种抽象和封装的设计思想。比如，Repository 层封装了对数据库访问的操作，提供了抽象的数据访问接口。**基于接口而非实现编程的设计思想，Service 层使用 Repository 层提供的接口，并不关心其底层依赖的是哪种具体的数据库**。当我们需要替换数据库的时候，比如从 MySQL 到 Oracle，从 Oracle 到 Redis，只需要改动 Repository 层的代码，Service 层的代码完全不需要修改。

除此之外，Controller、Service、Repository 三层代码的稳定程度不同、引起变化的原因不同，所以分成三层来组织代码，能有效地隔离变化。比如：

- Repository 层基于数据库表，而数据库表改动的可能性很小，所以 Repository 层的代码最稳定。
- Controller 层提供适配给外部使用的接口，代码经常会变动。分层之后，Controller 层中代码的频繁改动并不会影响到稳定的 Repository 层。

### 3. 分层能起到**隔离关注点**的作用

- Repository 层只关注数据的读写。
- Service 层只关注业务逻辑，不关注数据的来源。
- Controller 层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。

三层之间的关注点不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好。

### 4. 分层能提高代码的可测试性

**单元测试不依赖不可控的外部组件，比如数据库**。分层之后，Repsitory 层的代码通过依赖注入的方式供 Service 层使用，当要测试包含核心业务逻辑的 Service 层代码的时候，我们可以**用 mock 的数据源替代真实的数据库，注入到 Service 层代码中**。

### 5. 分层能应对系统的复杂性

所有的代码都放到一个类中，那这个类的代码就会因为**需求的迭代**而**无限膨胀**。我们知道，当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。那我们就要想办法拆分。拆分有**垂直**和**水平**两个方向。

- 水平方向：基于**业务**来做拆分，就是**模块化**；
- 垂直方向：基于**流程**来做拆分，就是**分层**。

还是那句话，不管是**分层、模块化**，还是 **OOP、DDD**，以及**各种设计模式、原则和思想**，都是为了应对**复杂系统**，应对**系统的复杂性**。对于**简单系统**来说，其实是**发挥不了作用**的，就是俗话说的“**杀鸡焉用牛刀**”。

## 问题

##### BO、VO、Entity 存在的意义是什么？

- **VO、BO、Entity 并非完全一样**。比如，我们可以在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密码暴露出去。
- **VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背 DRY 原则**。在前面讲到 DRY 原则的时候，针对这种情况，如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题。
- **为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互**。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。**对于非常大的项目来说，结构清晰是第一位的**！

##### VO、BO、Entity 不能合并，如何解决代码重复的问题？

- **继承**可以解决代码重复问题。我们可以将**公共的字段**定义在**父类**中，让 VO、BO、Entity 都**继承**这个父类，各自只定义特有的字段。因为这里的**继承层次很浅**，也不复杂，所以使用继承并不会影响代码的可读性和可维护性。后期如果因为业务的需要，有些字段需要从父类移动到子类，或者从子类提取到父类，代码改起来也并不复杂。
- **组合**也可以解决代码重复的问题，所以，这里我们还可以将**公共的字段**抽取到**公共的类中**，VO、BO、Entity 通过**组合关系**来复用这个类的代码。

##### 代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？

**最简单**的转化方式是**手动复制**。自己写代码在两个对象之间，一个字段一个字段的赋值。但这样的做法显然是没有技术含量的低级劳动。Java 中提供了多种**数据对象转化工具**，比如 **BeanUtils、Dozer 等**，可以大大简化繁琐的对象转化工作。如果你是用其他编程语言来做开发，也可以借鉴 Java 这些工具类的设计思路，自己在项目中实现对象转化工具类。

##### VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set 方法。这些都违背 OOP 的封装特性，会导致数据被随意修改。那到底该怎么办好呢？

Entity 和 VO 的生命周期是有限的，都仅限在本层范围内。而对应的 Repository 层和 Controller 层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的 set 方法，**相对来说也是安全的**。

不过，Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。但是，**设计的问题本身就没有最优解，只有权衡**。为了使用方便，我们只能做一些**妥协**，放弃 BO 的封装特性，由**程序员自己来负责**这些数据对象的不被错误使用。

## 结用到的设计原则和思想

很多人做业务开发，总感觉就是 CRUD，翻译代码，根本用不到设计原则、思想和模式。实际上，只是没有发现而已。现在，我们罗列一下，一般的单体系统设计，都用到了哪些设计原则、思想和模式。

![img](业务系统开发.assets/3332071c82182e72518143d05b8eaa61.jpg)